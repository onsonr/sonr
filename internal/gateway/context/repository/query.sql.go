// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package repository

import (
	"context"
)

const checkHandleExists = `-- name: CheckHandleExists :one
SELECT COUNT(*) > 0 as handle_exists FROM users 
WHERE handle = ? 
AND deleted_at IS NULL
`

func (q *Queries) CheckHandleExists(ctx context.Context, handle string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkHandleExists, handle)
	var handle_exists bool
	err := row.Scan(&handle_exists)
	return handle_exists, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
    id,
    browser_name,
    browser_version,
    platform,
    is_desktop,
    is_mobile,
    is_tablet,
    is_tv,
    is_bot,
    challenge,
    is_human_first,
    is_human_last
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, created_at, updated_at, deleted_at, browser_name, browser_version, platform, is_desktop, is_mobile, is_tablet, is_tv, is_bot, challenge, is_human_first, is_human_last
`

type CreateSessionParams struct {
	ID             string
	BrowserName    string
	BrowserVersion string
	Platform       string
	IsDesktop      int64
	IsMobile       int64
	IsTablet       int64
	IsTv           int64
	IsBot          int64
	Challenge      string
	IsHumanFirst   int64
	IsHumanLast    int64
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, createSession,
		arg.ID,
		arg.BrowserName,
		arg.BrowserVersion,
		arg.Platform,
		arg.IsDesktop,
		arg.IsMobile,
		arg.IsTablet,
		arg.IsTv,
		arg.IsBot,
		arg.Challenge,
		arg.IsHumanFirst,
		arg.IsHumanLast,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.BrowserName,
		&i.BrowserVersion,
		&i.Platform,
		&i.IsDesktop,
		&i.IsMobile,
		&i.IsTablet,
		&i.IsTv,
		&i.IsBot,
		&i.Challenge,
		&i.IsHumanFirst,
		&i.IsHumanLast,
	)
	return i, err
}

const getCredentialByID = `-- name: GetCredentialByID :one
SELECT id, created_at, updated_at, deleted_at, handle, credential_id, origin, type, transports FROM credentials
WHERE credential_id = ?
AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetCredentialByID(ctx context.Context, credentialID string) (Credential, error) {
	row := q.db.QueryRowContext(ctx, getCredentialByID, credentialID)
	var i Credential
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Handle,
		&i.CredentialID,
		&i.Origin,
		&i.Type,
		&i.Transports,
	)
	return i, err
}

const getCredentialsByHandle = `-- name: GetCredentialsByHandle :many
SELECT id, created_at, updated_at, deleted_at, handle, credential_id, origin, type, transports FROM credentials
WHERE handle = ?
AND deleted_at IS NULL
`

func (q *Queries) GetCredentialsByHandle(ctx context.Context, handle string) ([]Credential, error) {
	rows, err := q.db.QueryContext(ctx, getCredentialsByHandle, handle)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Credential
	for rows.Next() {
		var i Credential
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Handle,
			&i.CredentialID,
			&i.Origin,
			&i.Type,
			&i.Transports,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, created_at, updated_at, deleted_at, browser_name, browser_version, platform, is_desktop, is_mobile, is_tablet, is_tv, is_bot, challenge, is_human_first, is_human_last FROM sessions
WHERE id = ? AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetSessionByID(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSessionByID, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.BrowserName,
		&i.BrowserVersion,
		&i.Platform,
		&i.IsDesktop,
		&i.IsMobile,
		&i.IsTablet,
		&i.IsTv,
		&i.IsBot,
		&i.Challenge,
		&i.IsHumanFirst,
		&i.IsHumanLast,
	)
	return i, err
}

const getUserByAddress = `-- name: GetUserByAddress :one
SELECT id, created_at, updated_at, deleted_at, address, handle, origin, name, cid FROM users
WHERE address = ? AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetUserByAddress(ctx context.Context, address string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByAddress, address)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Address,
		&i.Handle,
		&i.Origin,
		&i.Name,
		&i.Cid,
	)
	return i, err
}

const getUserByHandle = `-- name: GetUserByHandle :one
SELECT id, created_at, updated_at, deleted_at, address, handle, origin, name, cid FROM users
WHERE handle = ? 
AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetUserByHandle(ctx context.Context, handle string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByHandle, handle)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Address,
		&i.Handle,
		&i.Origin,
		&i.Name,
		&i.Cid,
	)
	return i, err
}

const insertCredential = `-- name: InsertCredential :one
INSERT INTO credentials (
    handle,
    credential_id,
    origin,
    type,
    transports
) VALUES (?, ?, ?, ?, ?)
RETURNING id, created_at, updated_at, deleted_at, handle, credential_id, origin, type, transports
`

type InsertCredentialParams struct {
	Handle       string
	CredentialID string
	Origin       string
	Type         string
	Transports   string
}

func (q *Queries) InsertCredential(ctx context.Context, arg InsertCredentialParams) (Credential, error) {
	row := q.db.QueryRowContext(ctx, insertCredential,
		arg.Handle,
		arg.CredentialID,
		arg.Origin,
		arg.Type,
		arg.Transports,
	)
	var i Credential
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Handle,
		&i.CredentialID,
		&i.Origin,
		&i.Type,
		&i.Transports,
	)
	return i, err
}

const insertUser = `-- name: InsertUser :one
INSERT INTO users (
    address,
    handle,
    origin,
    name
) VALUES (?, ?, ?, ?)
RETURNING id, created_at, updated_at, deleted_at, address, handle, origin, name, cid
`

type InsertUserParams struct {
	Address string
	Handle  string
	Origin  string
	Name    string
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, insertUser,
		arg.Address,
		arg.Handle,
		arg.Origin,
		arg.Name,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Address,
		&i.Handle,
		&i.Origin,
		&i.Name,
		&i.Cid,
	)
	return i, err
}

const softDeleteCredential = `-- name: SoftDeleteCredential :exec
UPDATE credentials
SET deleted_at = CURRENT_TIMESTAMP
WHERE credential_id = ?
`

func (q *Queries) SoftDeleteCredential(ctx context.Context, credentialID string) error {
	_, err := q.db.ExecContext(ctx, softDeleteCredential, credentialID)
	return err
}

const softDeleteUser = `-- name: SoftDeleteUser :exec
UPDATE users
SET deleted_at = CURRENT_TIMESTAMP
WHERE address = ?
`

func (q *Queries) SoftDeleteUser(ctx context.Context, address string) error {
	_, err := q.db.ExecContext(ctx, softDeleteUser, address)
	return err
}

const updateSessionHumanVerification = `-- name: UpdateSessionHumanVerification :one
UPDATE sessions
SET 
    is_human_first = ?,
    is_human_last = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
RETURNING id, created_at, updated_at, deleted_at, browser_name, browser_version, platform, is_desktop, is_mobile, is_tablet, is_tv, is_bot, challenge, is_human_first, is_human_last
`

type UpdateSessionHumanVerificationParams struct {
	IsHumanFirst int64
	IsHumanLast  int64
	ID           string
}

func (q *Queries) UpdateSessionHumanVerification(ctx context.Context, arg UpdateSessionHumanVerificationParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, updateSessionHumanVerification, arg.IsHumanFirst, arg.IsHumanLast, arg.ID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.BrowserName,
		&i.BrowserVersion,
		&i.Platform,
		&i.IsDesktop,
		&i.IsMobile,
		&i.IsTablet,
		&i.IsTv,
		&i.IsBot,
		&i.Challenge,
		&i.IsHumanFirst,
		&i.IsHumanLast,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET 
    name = ?,
    handle = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE address = ? 
AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, address, handle, origin, name, cid
`

type UpdateUserParams struct {
	Name    string
	Handle  string
	Address string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateUser, arg.Name, arg.Handle, arg.Address)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Address,
		&i.Handle,
		&i.Origin,
		&i.Name,
		&i.Cid,
	)
	return i, err
}
