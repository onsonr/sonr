// Code generated by templ - DO NOT EDIT.

// templ: version: v0.2.793
package credentials

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

var credentialsHandle = templ.NewOnceHandle()

// Types for credential data
type PublicKeyCredentialCreationOptions struct {
	Challenge       string `json:"challenge"`
	RpName          string `json:"rpName"`
	RpID            string `json:"rpId"`
	UserID          string `json:"userId"`
	UserName        string `json:"userName"`
	UserDisplayName string `json:"userDisplayName"`
	Timeout         int    `json:"timeout,omitempty"`
	AttestationType string `json:"attestationType,omitempty"`
}

type PublicKeyCredentialRequestOptions struct {
	Challenge        string                 `json:"challenge"`
	RpID             string                 `json:"rpId"`
	Timeout          int                    `json:"timeout,omitempty"`
	UserVerification string                 `json:"userVerification,omitempty"`
	AllowCredentials []CredentialDescriptor `json:"allowCredentials,omitempty"`
}

type CredentialDescriptor struct {
	Type string `json:"type"`
	ID   string `json:"id"`
}

// Base credentials script template
func CredentialsScripts() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Var2 := templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
			templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
			templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
			if !templ_7745c5c3_IsBuffer {
				defer func() {
					templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
					if templ_7745c5c3_Err == nil {
						templ_7745c5c3_Err = templ_7745c5c3_BufErr
					}
				}()
			}
			ctx = templ.InitializeContext(ctx)
			_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString("<script type=\"text/javascript\">\n            // Check if WebAuthn is supported\n            async function isWebAuthnSupported() {\n                return window.PublicKeyCredential !== undefined;\n            }\n\n            // Create credentials\n            async function createCredential(options) {\n                try {\n                    const publicKey = {\n                        challenge: base64URLDecode(options.challenge),\n                        rp: {\n                            name: options.rpName,\n                            id: options.rpId,\n                        },\n                        user: {\n                            id: base64URLDecode(options.userId),\n                            name: options.userName,\n                            displayName: options.userDisplayName,\n                        },\n                        pubKeyCredParams: [{alg: -7, type: \"public-key\"}],\n                        timeout: options.timeout || 60000,\n                        attestation: options.attestationType || \"none\",\n                    };\n                    \n                    const credential = await navigator.credentials.create({\n                        publicKey: publicKey\n                    });\n                    \n                    return {\n                        id: credential.id,\n                        rawId: arrayBufferToBase64URL(credential.rawId),\n                        type: credential.type,\n                        response: {\n                            attestationObject: arrayBufferToBase64URL(credential.response.attestationObject),\n                            clientDataJSON: arrayBufferToBase64URL(credential.response.clientDataJSON),\n                        }\n                    };\n                } catch (err) {\n                    console.error('Error creating credential:', err);\n                    throw err;\n                }\n            }\n\n            // Get credentials\n            async function getCredential(options) {\n                try {\n                    const publicKey = {\n                        challenge: base64URLDecode(options.challenge),\n                        rpId: options.rpId,\n                        timeout: options.timeout || 60000,\n                        userVerification: options.userVerification || \"preferred\",\n                    };\n\n                    if (options.allowCredentials) {\n                        publicKey.allowCredentials = options.allowCredentials.map(cred => ({\n                            type: cred.type,\n                            id: base64URLDecode(cred.id),\n                        }));\n                    }\n\n                    const assertion = await navigator.credentials.get({\n                        publicKey: publicKey\n                    });\n\n                    return {\n                        id: assertion.id,\n                        rawId: arrayBufferToBase64URL(assertion.rawId),\n                        type: assertion.type,\n                        response: {\n                            authenticatorData: arrayBufferToBase64URL(assertion.response.authenticatorData),\n                            clientDataJSON: arrayBufferToBase64URL(assertion.response.clientDataJSON),\n                            signature: arrayBufferToBase64URL(assertion.response.signature),\n                            userHandle: assertion.response.userHandle ? arrayBufferToBase64URL(assertion.response.userHandle) : null\n                        }\n                    };\n                } catch (err) {\n                    console.error('Error getting credential:', err);\n                    throw err;\n                }\n            }\n\n            // Utility functions for base64URL encoding/decoding\n            function base64URLDecode(base64url) {\n                const padding = '='.repeat((4 - base64url.length % 4) % 4);\n                const base64 = (base64url + padding)\n                    .replace(/\\-/g, '+')\n                    .replace(/_/g, '/');\n                const rawData = window.atob(base64);\n                const array = new Uint8Array(rawData.length);\n                for (let i = 0; i < rawData.length; i++) {\n                    array[i] = rawData.charCodeAt(i);\n                }\n                return array.buffer;\n            }\n\n            function arrayBufferToBase64URL(buffer) {\n                let binary = '';\n                const bytes = new Uint8Array(buffer);\n                for (let i = 0; i < bytes.byteLength; i++) {\n                    binary += String.fromCharCode(bytes[i]);\n                }\n                const base64 = window.btoa(binary);\n                return base64\n                    .replace(/\\+/g, '-')\n                    .replace(/\\//g, '_')\n                    .replace(/=/g, '');\n            }\n        </script>")
			if templ_7745c5c3_Err != nil {
				return templ_7745c5c3_Err
			}
			return templ_7745c5c3_Err
		})
		templ_7745c5c3_Err = credentialsHandle.Once().Render(templ.WithChildren(ctx, templ_7745c5c3_Var2), templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return templ_7745c5c3_Err
	})
}

// Template for creating credentials
func CreateCredential(options PublicKeyCredentialCreationOptions) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var3 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var3 == nil {
			templ_7745c5c3_Var3 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = CredentialsScripts().Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString("<script>\n        (async () => {\n            try {\n                if (!await isWebAuthnSupported()) {\n                    throw new Error(\"WebAuthn is not supported in this browser\");\n                }\n                const options = { templ.JSONString(options) };\n                const credential = await createCredential(options);\n                // Dispatch event with credential data\n                window.dispatchEvent(new CustomEvent('credentialCreated', {\n                    detail: credential\n                }));\n            } catch (err) {\n                window.dispatchEvent(new CustomEvent('credentialError', {\n                    detail: err.message\n                }));\n            }\n        })();\n    </script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return templ_7745c5c3_Err
	})
}

// Template for getting credentials
func GetCredential(options PublicKeyCredentialRequestOptions) templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var4 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var4 == nil {
			templ_7745c5c3_Var4 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = CredentialsScripts().Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString("<script>\n        (async () => {\n            try {\n                if (!await isWebAuthnSupported()) {\n                    throw new Error(\"WebAuthn is not supported in this browser\");\n                }\n                const options = { templ.JSONString(options) };\n                const credential = await getCredential(options);\n                // Dispatch event with credential data\n                window.dispatchEvent(new CustomEvent('credentialRetrieved', {\n                    detail: credential\n                }));\n            } catch (err) {\n                window.dispatchEvent(new CustomEvent('credentialError', {\n                    detail: err.message\n                }));\n            }\n        })();\n    </script>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return templ_7745c5c3_Err
	})
}

var _ = templruntime.GeneratedTemplate
